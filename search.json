[{"url":"/2024/03/14/JVM/","content":"1、垃圾收集器1.1、serial收集器单线程作用域: 新生代算法: 标记-复制算法\n-XX:+UseSerialGC\n\n\n1.2、ParNew收集器多线程作用域: 新生代算法: 标记-复制算法\nXX:ParallelGCThreads 参数来限制垃圾收集器的线程数。\n\n1.3、Parallel Scavenge收集器多线程作用域: 新生代算法: 标记-复制算法高吞吐量: Parallel Scavenge 重点关注的是程序达到一个可控制的吞吐量（Thoughput，吞吐量 &#x3D; 运行用户代码时间 &#x2F; (运行用户代码时间 + 垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务；特点:如何达到控制吞吐量？\n1.4、Serial Old收集器单线程作用域: 老年代算法: 标记-整理算法\n1.5、Parallel Old收集器多线程作用域: 老年代算法: 标记-整理算法\n1.6、CMS收集器多线程作用域: 老年代算法: 标记-清除算法CMS 运行过程分为以下 4 个阶段：初始标记：标记 GC Roots 能直接关联的对象（速度很快，需要暂停所有的工作线程）；并发标记：进行 GC Roots 跟踪（和用户线程一起工作，不需要暂停工作线程）；重新标记：修正因用户程序继续运行而导致标记产生变动的那一部分对象的标记（需要暂停所有的工作线程）；并发清除：清除 GC Roots 不可达对象（和用户线程一起工作，不需要暂停工作线程）。\n-XX:+UseConcMarkSweepGC\nCMS核心参数1.-XX:+UseConcMarkSweepGC：启用cms;\n2.-XX:ConcGCThreads：并发的GC线程数;\n3.-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（整理碎片,也就是浮动垃圾）;\n4.-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，(默认是0，代表每次FullGC后都会压缩一次&#x2F;错误知识点);\n5.-XX:CMSInitiatingOccupancyFraction: 当老年代内存使用达到该比例时会触发FullGC（默认是92，这是百分比）&#x3D;&#x3D;&gt; 解决concurrent mode failure问题, 让其不会等到内存快用完了,才去做full gc\n6.-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设\n定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整百分比;\n7.-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段;\n8.-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW;\n9.-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;\n1.7、G1收集器无分代: G1 将新生代，老年代的物理空间划分取消了。这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够；标记-整理算法: G1 收集器采用标记-整理算法，无内存碎片产生；分区回收: G1 虽然没有了新生代与老年代的物理限制，但是 G1 采取内存分区策略，将堆内存划分为大小固定的几个独立区域。在分区中，同时存在新生代与老年代；停顿时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划可以用参数”-XX:G1HeapRegionSize”手动指定Region大小\nG1 垃圾收集分类1、YoungGC\nYoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC；\n2、MixedGC\n不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC；\n3、Full GC\n停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了) ；\nG1收集器参数设置-XX:+UseG1GC:使用G1收集器\n-XX:ParallelGCThreads:指定GC工作的线程数量\n-XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区\n-XX:MaxGCPauseMillis:目标暂停时间(默认200ms)\n-XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%)\n-XX:G1MaxNewSizePercent:新生代内存最大空间\n-XX:TargetSurvivorRatio:Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代\n-XX:MaxTenuringThreshold:最大年龄阈值(默认15)\n-XX:InitiatingHeapOccupancyPercent:老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的混合收集(MixedGC)，比如我们之前说的堆默认有2048个region，如果有接近1000个region都是老年代的region，则可能 就要触发MixedGC了\n-XX:G1MixedGCLiveThresholdPercent(默认85%) region中的存活对象低于这个值时才会回收该region，如果超过这 个值，存活对象过多，回收的的意义不大。\n-XX:G1MixedGCCountTarget:在一次回收过程中指定做几次筛选回收(默认8次)，在最后一个筛选回收阶段可以回收一会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至于单次停顿时间过长。\n-XX:G1HeapWastePercent(默认5%): gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都 是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。\n\n\n\n垃圾收集器\n分类\n作用位置\n使用算法\n特点\n适用场景\n别名\n\n\n\nSerial\n串行\n新生代\n复制算法\n响应速度优先\n适用于单CPU环境下的client模式\nCopy\n\n\nParNew\n并行\n新生代\n复制算法\n响应速度优先\n多CPU环境Server模式下与CMS配合使用\nParNew\n\n\nParallel\n并行\n新生代\n复制算法\n吞吐量优先\n适用于后台运算而不需要太多交互的场景\nPS Scavenge\n\n\nSerial Old\n串行\n老年代\n标记-整理(压缩)算法\n响应速度优先\n适用于单CPU环境下的Client模式\nMarkSweepCompact\n\n\nParaller Old\n并行\n老年代\n标记-整理(压缩)算法\n吞吐量优先\n适用于后台运算而不需要太多交互的场景\nPS MarkSweep\n\n\nCMS\n并发\n老年代\n标记-清除算法\n响应速度优先\n适用于互联网或B／S业务\nConcurrentMarkSweep\n\n\nG1\n并发、并行\n新生代、老年代\n标记-整理(压缩)算法\n响应速度优先\n响应速度优先\nG1 Mixed Generation\n\n\n补充学习\nhttps://blog.csdn.net/weixin_46209120/article/details/132812808\n1.8 收集器组合\n\n\nYoung\nTenured\nJVM options\nDescription\n\n\n\nSerial\nSerial Old\n-XX:+UseSerialGC\n单线程进行GC，适合单CPU或小内存，单机程序\n\n\nSerial–\nCMS+SerialOld\n-XX:-UseParNewGC -XX:+UseConcMarkSweepGC\nCMS进行GC失败时，会自动使用Serial Old 策略进行GC；JDK8中声明为废弃\n\n\nParallel Scavenge\nSerial Old\n-XX:+UseParallelGC\nJdk1.5及之前版本的搭配使用\n\n\nParallel Scavenge\nParallel Old\n-XX:+UseParallelGC -XX:+UseParallelOldGC\n适合多CPU，需要最大吞吐量，如后台计算型应用；是JDK8默认收集器策略\n\n\nParallel New–\nSerial Old\n-XX:+UseParNewGC\nJDK8中声明为废弃\n\n\nParallel New\nCMS+SerialOld\n-XX:+UseParNewGC -XX:+UseConcMarkSweepGC\n适合多CPU，追求低停顿时间，需快速响应如互联网应用\n\n\nG1\n\n-XX:+UseG1GC\nJDK9默认收集器\n\n\nZGC\n\n-XX:+UseZGC\n\n\n\n2、JVM jdk自带工具2.1 jmapjmap是java内存映像工具，主要用于查询当前堆和方法区的详细信息，生成堆的快照文件等。一般都是使用-XX:+HeapDumpOnOutOfMemoryError参数指定JVM在内存溢出异常时自动生成堆的快照文件。之后在服务器发生内存溢出异常时，将对应的快照文件拉取到本地使用工具分析。\n常用命令\n查看java堆使用情况jmap -heap pid将内存使用输出至文件jmap -dump:format=b,file=heapDump pid生成的文件配合jhat命令可查看详细情况jhat -port 5000 heapDump\n\n\n2.2 jstackjstack用于生成java虚拟机当前时刻线程快照，可定位线程死锁，死循环\n常用命令\njstack pid\n\n\n\n3、其他工具3.1 Arthas在命令行下面执行（使用和目标进程一致的用户启动，否则可能 attach 失败）：\ncurl -O https://arthas.aliyun.com/arthas-boot.jarjava -jar arthas-boot.jar\n\n\n\n3.1.1 dashboarddashboard\n\n\n\n\n\n3.1.2 jad反编译文件\njad &lt;全路径名&gt;\n\n\n\n\n\n3.1.3 trace\n方法耗时跟踪\ntrace &lt;全路径名&gt; &lt;方法名&gt;\n\n\n\n4、问题如何调优？1、调整堆内存的大小2、调整垃圾回收器3、设置新生代和老年代比例4、设置GC线程数6、使用合适数据结构，减少对象创建\n1、设置基础JVM参数设置内存大小参数设置元空间大小参数 -XX:MaxMetaspaceSize 最大值：防止向操作系统内存中占用大小 一般256m  -XX:MetaspaceSize 这个值代表进行fullgc清理预值 两者一样不会发生fullgc设置虚拟机栈大小 -Xss 根据操作系统值不一样 x86_64 1M不建议手动调节\n\n-Xmn 设置年轻代大小，默认为整个堆大小的1&#x2F;3(G1不建议)\n-XX:MaxTenuringThreshold 最大晋升值\n-XX:HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;\n-XX:+PrintGCDetails -XX:PrintGCDateStamps -Xloggc:文件路径2、利用良好数据结构，减少对象创建3、更换匹配的垃圾回收器4、优化垃圾回收器参数\n\n垃圾回收器如何选择？1、优先调整堆的大小让JVM自己选择2、内存很小或者单核机器直接串行 或 JVM自己选择3、如果允许停顿时间超过1秒，选择并行或者JVM自己选4、如果响应时间最重要，并且不能超过1秒，使用并发收集器5、4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC\n"},{"title":"MAT的下载及安装","url":"/2023/07/01/MAT%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%AE%89%E8%A3%85/","content":"下载地址MAT 工具可以通过下面的 官网下载地址，进行工具的下载，下载地址如下：\nhttps://www.eclipse.org/mat/downloads.php\n\nMac m2 安装由于不同MAT需要不同的java版本，所以要进行对MAT工具进行更改所需要的java版本\n首先打开MAT的包内容的文件进行更改，文件路径是\n/Applications/MemoryAnalyzer.app/Contents/Eclipse\n\n可以通过访达访问再用工具打开，也可以在终端修改\ncd /Applications/mat.app\n其次，修改环境变量修改MemoryAnalyzer.ini文件，在第4行的下面 -vmargs 上面进行添加\n-vm/Users/xxc/tool/zulu-17.jdk/Contents/Home/bin\n\n这里路径需要修改成自己的jdk路径，不知道可以在idea中找。\n"},{"title":"hexo博客自动部署 Github pages","url":"/2023/05/01/hexo%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","content":"https://juejin.cn/post/6943895271751286821\n"},{"title":"LRU+定期删除","url":"/2023/12/06/%E5%88%B7%E9%A2%98/","content":"直接上代码\npackage com.kael.modules.data;import org.jetbrains.annotations.NotNull;import java.util.*;import java.util.concurrent.DelayQueue;import java.util.concurrent.Delayed;import java.util.concurrent.TimeUnit;/** * 设计一个对象cache, 他支持下列两个基本操作: * set(id, object), 根据id设置对象; * get(id): 根据id得到一个对象; * 同时它有下面几个性质: * 1: x秒自动过期, 如果cache内的对象, x秒内没有被get或者set过, 则会自动过期; * 2: 对象数限制, 该cache可以设置一个n, 表示cache最多能存储的对象数; * 3: LRU置换, 当进行set操作时, 如果此时cache内对象数已经到达了n个, * 则cache自动将最久未被使用过的那个对象剔除, 腾出空间放置新对象; * 请你设计这样一个cache; */public class LRUTest &#123;    public static void main(String[] args) &#123;        LRUTest lruTest = new LRUTest(5);        lruTest.put(1,1,0);        lruTest.put(2,2,1);        lruTest.put(6,6,1);        lruTest.print();        lruTest.put(3,3,10);        lruTest.print();        try &#123;            Thread.sleep(3000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(&quot;&quot;);        lruTest.get(1);        lruTest.print();    &#125;    private Map&lt;Integer,Node&gt;  map ;    private Node head;    private Node tail;    private int cap;    private DelayQueue queue = new DelayQueue&lt;Node&gt;();    public LRUTest(int cap)&#123;        this.map = new HashMap&lt;&gt;();        this.head = new Node(0,0);        this.tail = new Node(0,0);        head.next = tail;        tail.pre = head;        this.cap = cap;        new Thread(()-&gt;&#123;            while (true)&#123;                try &#123;                    Node take = (Node) queue.take();                    this.removeNode(take);                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;        &#125;).start();    &#125;    /**     *     * @param node     */    public void addTail(Node node)&#123;        Node tailPre = tail.pre;        tail.pre = node;        node.next = tail;        node.pre = tailPre;        tailPre.next = node;    &#125;    /**     * 后移     * @param node     */    public void popToTail(Node node)&#123;        Node nodeNext = node.next;        Node nodePre = node.pre;        nodePre.next = nodeNext;        nodeNext.pre = nodePre;        Node tailPre = tail.pre;        tailPre.next = node;        node.pre = tailPre;        node.next = tail;        tail.pre = node;    &#125;    /**     * 过期清除节点     * @param node     */    public synchronized void removeNode(Node node)&#123;        if(map.get(node.key)!=null)&#123;            System.out.println(&quot;del node:&quot;+node);            Node nodeNext = node.next;            Node nodePre = node.pre;            nodePre.next = nodeNext;            nodeNext.pre = node.pre;            map.remove(node.key);        &#125;    &#125;    /**     * 移除第一个     */    public void removeFirst()&#123;        Node firstNode = head.next;        Node sce = firstNode.next;        head.next = sce;        sce.pre = head;        queue.remove(firstNode);    &#125;    /**     * 获取元素     * @param id     * @return     */    public synchronized Object get(int id)&#123;        if(map.get(id)!=null)&#123;            Node node = map.get(id);            queue.remove(node);            //刷新时间            node.refreshExpire(node.expire);            popToTail(node);            queue.put(node);            return map.get(id).value;        &#125;        return null;    &#125;    /**     * set     * @param id     * @param value     * @param expire     */    public synchronized void put(int id, Object value,int expire)&#123;        if(map.get(id)==null)&#123;            Node node = new Node(id, value,expire);            if(cap&lt;=map.size())&#123;                removeFirst();                map.remove(id);            &#125;            addTail(node);            map.put(id,node);            if(expire&gt;0)&#123;                queue.put(node);            &#125;        &#125; else &#123;            Node node = (Node) map.get(id);            popToTail(node);            if(expire&gt;0)&#123;                queue.remove(node);                //刷新时间                node.refreshExpire(expire);                queue.put(node);            &#125;        &#125;    &#125;    public void print()&#123;        Node node = head;        while (node.next!=null)&#123;            System.out.print(node.value + &quot; -&gt; &quot;);            node = node.next;        &#125;        System.out.println();    &#125;    class Node implements Delayed &#123;        public int expire;        public long expireTime;        public Integer key;        public Object value;        public Node pre;        public Node next;        public Node(Integer key, Object value) &#123;            this.key = key;            this.value = value;        &#125;        public Node(Integer key, Object value,int expire) &#123;            this.key = key;            this.value = value;            this.expire = expire;            this.expireTime = new Date().getTime() + expire*1000;        &#125;        public void refreshExpire(int expire)&#123;            this.expire  = expire;            this.expireTime = new Date().getTime() + expire*1000;        &#125;        @Override        public long getDelay(@NotNull TimeUnit unit) &#123;            Date date = new Date();            return unit.convert(expireTime-date.getTime(),TimeUnit.MILLISECONDS);        &#125;        @Override        public int compareTo(@NotNull Delayed o) &#123;            if(o instanceof  Node)&#123;                Node node = (Node)o;                //排后面                if(expireTime &gt; node.expireTime)&#123;                    return 1;                &#125;                //排前面                if(expireTime &lt;= node.expireTime)&#123;                    return -1;                &#125;            &#125;            return 0;        &#125;        @Override        public String toString() &#123;            return &quot;Node&#123;&quot; +                    &quot;expire=&quot; + expire +                    &quot;, expireTime=&quot; + expireTime +                    &quot;, key=&quot; + key +                    &quot;, value=&quot; + value +                    &#x27;&#125;&#x27;;        &#125;    &#125;&#125;\n"},{"title":"此域名出售","url":"/2023/09/14/%E5%9F%9F%E5%90%8D%E5%87%BA%E5%94%AE/","content":"此域名出售\n需要请联系我&#x31;&#x34;&#56;&#49;&#54;&#x33;&#x38;&#57;&#x31;&#55;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;\n"},{"title":"记一次从Reids取JDK序列化对象","url":"/2023/10/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%8EReids%E5%8F%96JDK%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1/","content":"1、问题描述当时场景: 排查问题，需查看看redis的JDK序列化后的对象数据, 不能直联redis \n当时思路:使用redis命令查出对应key的数据get xxx利用查出来的数据, 直接序列化一时没有立马解决, 现回顾问题并排除知识盲区\n2、解决步骤./redis-cli -a password get user &gt; aa.txt\n\npublic class RedisTest &#123;        public static Object deserialize() throws Exception &#123;        FileInputStream fileInputStream = new FileInputStream(new File(&quot;aa.txt&quot;));        ObjectInputStream in = new ObjectInputStream(fileInputStream);        Object o = in.readObject();        System.out.println(o);        return o;    &#125;    public static void main(String[] args) throws Exception &#123;        deserialize();    &#125;&#125;\n\n3、问题盲区3.1 问题1redis用命令行取出来的数据 二进制部分数据会被16进制处理来好显示出来\n3.2 问题2序列化ID 其实不是必要的 反序列化会直接提示与对比的结果不同，会直接显示两个不通的序列化ID\n4、补充假如key也被jdk序列化，key在用命令行输入时不好直接输入 或者 输入的方式不对\n#!/bin/bash# Redis服务器连接信息REDIS_HOST=&quot;localhost&quot;REDIS_PORT=&quot;6379&quot;REDIS_PASSWORD=&quot;xxx&quot;  # 替换为你的Redis密码# 匹配的键模式KEY_PATTERN=&quot;*user&quot;# 输出文件目录OUTPUT_DIRECTORY=&quot;output/&quot;# 创建输出目录mkdir -p &quot;$OUTPUT_DIRECTORY&quot;# 使用KEYS命令进行模糊查询keys=$(./redis-cli -h $REDIS_HOST -p $REDIS_PORT -a &quot;$REDIS_PASSWORD&quot; KEYS &quot;$KEY_PATTERN&quot;)index=0for key in $keys; do    # 使用GET命令获取键的值    value=$(./redis-cli -h $REDIS_HOST -p $REDIS_PORT -a &quot;$REDIS_PASSWORD&quot; GET &quot;$key&quot;)        # 为每个键创建一个单独的文件，以键名命名    file_name=&quot;$OUTPUT_DIRECTORY$index.txt&quot;        echo &quot;$key -&gt; $file_name&quot;           # 保存值到文件    echo &quot;$value&quot; &gt; &quot;$file_name&quot;        ((index++)) doneecho &quot;Values matching pattern &#x27;$KEY_PATTERN&#x27; saved to files in &#x27;$OUTPUT_DIRECTORY&#x27;.&quot;\n以上脚本更换你要匹配的key值，会将所有可能匹配的key进行数据到文件夹中output/,根据控制开打印key对应的文件得到文件\n"}]